# HG changeset patch
# User Garvan Keeley <gkeeley@mozilla.com>
# Parent  c9b84a6fb52fbdea2dddc0f2ee5f2bc39d30fdde
Bug 1145111 - make geo position cache static, thus useable over longer time period. r=jdm

diff --git a/dom/geolocation/nsGeolocation.cpp b/dom/geolocation/nsGeolocation.cpp
--- a/dom/geolocation/nsGeolocation.cpp
+++ b/dom/geolocation/nsGeolocation.cpp
@@ -62,16 +62,18 @@ class nsIPrincipal;
 
 // the geolocation enabled setting
 #define GEO_SETTINGS_ENABLED          "geolocation.enabled"
 
 using mozilla::unused;          // <snicker>
 using namespace mozilla;
 using namespace mozilla::dom;
 
+StaticRefPtr<CachedPositionAndAccuracy> nsGeolocationService::sLastPosition;
+
 class nsGeolocationRequest final
  : public nsIContentPermissionRequest
  , public nsITimerCallback
  , public nsIGeolocationUpdate
 {
  public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_NSICONTENTPERMISSIONREQUEST
@@ -471,37 +473,37 @@ nsGeolocationRequest::Allow(JS::HandleVa
 
   if (NS_FAILED(rv)) {
     // Location provider error
     NotifyError(nsIDOMGeoPositionError::POSITION_UNAVAILABLE);
     return NS_OK;
   }
 
   bool canUseCache = false;
-  CachedPositionAndAccuracy lastPosition = gs->GetCachedPosition();
-  if (lastPosition.position) {
+  nsRefPtr<CachedPositionAndAccuracy> lastPosition = gs->GetCachedPosition();
+  if (lastPosition->position) {
     DOMTimeStamp cachedPositionTime_ms;
-    lastPosition.position->GetTimestamp(&cachedPositionTime_ms);
+    lastPosition->position->GetTimestamp(&cachedPositionTime_ms);
     // check to see if we can use a cached value
     // if the user has specified a maximumAge, return a cached value.
     if (mOptions && mOptions->mMaximumAge > 0) {
       uint32_t maximumAge_ms = mOptions->mMaximumAge;
-      bool isCachedWithinRequestedAccuracy = WantsHighAccuracy() <= lastPosition.isHighAccuracy;
+      bool isCachedWithinRequestedAccuracy = WantsHighAccuracy() <= lastPosition->isHighAccuracy;
       bool isCachedWithinRequestedTime =
         DOMTimeStamp(PR_Now() / PR_USEC_PER_MSEC - maximumAge_ms) <= cachedPositionTime_ms;
       canUseCache = isCachedWithinRequestedAccuracy && isCachedWithinRequestedTime;
     }
   }
 
   gs->UpdateAccuracy(WantsHighAccuracy());
   if (canUseCache) {
     // okay, we can return a cached position
     // getCurrentPosition requests serviced by the cache
     // will now be owned by the RequestSendLocationEvent
-    Update(lastPosition.position);
+    Update(lastPosition->position);
   }
 
   if (mIsWatchPositionRequest || !canUseCache) {
     // let the locator know we're pending
     // we will now be owned by the locator
     mLocator->NotifyAllowedRequest(this);
   }
 
@@ -893,17 +895,16 @@ nsGeolocationService::HandleMozsettingCh
 
 void
 nsGeolocationService::HandleMozsettingValue(const bool aValue)
 {
     if (!aValue) {
       // turn things off
       StopDevice();
       Update(nullptr);
-      mLastPosition.position = nullptr;
       sGeoEnabled = false;
     } else {
       sGeoEnabled = true;
     }
 
     if (sGeoInitPending) {
       sGeoInitPending = false;
       for (uint32_t i = 0, length = mGeolocators.Length(); i < length; ++i) {
@@ -983,24 +984,29 @@ nsGeolocationService::NotifyError(uint16
   }
 
   return NS_OK;
 }
 
 void
 nsGeolocationService::SetCachedPosition(nsIDOMGeoPosition* aPosition)
 {
-  mLastPosition.position = aPosition;
-  mLastPosition.isHighAccuracy = mHigherAccuracy;
+  nsRefPtr<CachedPositionAndAccuracy> cache = GetCachedPosition();
+  cache->position = aPosition;
+  cache->isHighAccuracy = mHigherAccuracy;
 }
 
-CachedPositionAndAccuracy
+already_AddRefed<CachedPositionAndAccuracy>
 nsGeolocationService::GetCachedPosition()
 {
-  return mLastPosition;
+  if (!sLastPosition) {
+    sLastPosition = new CachedPositionAndAccuracy();
+    ClearOnShutdown(&sLastPosition);
+  }
+  return nsRefPtr<CachedPositionAndAccuracy>(sLastPosition.get()).forget();
 }
 
 nsresult
 nsGeolocationService::StartDevice(nsIPrincipal *aPrincipal)
 {
   if (!sGeoEnabled || sGeoInitPending) {
     return NS_ERROR_NOT_AVAILABLE;
   }
diff --git a/dom/geolocation/nsGeolocation.h b/dom/geolocation/nsGeolocation.h
--- a/dom/geolocation/nsGeolocation.h
+++ b/dom/geolocation/nsGeolocation.h
@@ -25,34 +25,40 @@
 #include "nsIDOMGeoGeolocation.h"
 #include "nsIDOMGeoPosition.h"
 #include "nsIDOMGeoPositionError.h"
 #include "nsIDOMGeoPositionCallback.h"
 #include "nsIDOMGeoPositionErrorCallback.h"
 #include "mozilla/dom/GeolocationBinding.h"
 #include "mozilla/dom/PositionErrorBinding.h"
 #include "mozilla/dom/CallbackObject.h"
-
+#include "mozilla/RefPtr.h"
 #include "nsIGeolocationProvider.h"
 #include "nsIContentPermissionPrompt.h"
 #include "nsIDOMWindow.h"
 #include "mozilla/Attributes.h"
 
 class nsGeolocationService;
 class nsGeolocationRequest;
 
 namespace mozilla {
 namespace dom {
 class Geolocation;
 typedef CallbackObjectHolder<PositionCallback, nsIDOMGeoPositionCallback> GeoPositionCallback;
 typedef CallbackObjectHolder<PositionErrorCallback, nsIDOMGeoPositionErrorCallback> GeoPositionErrorCallback;
 }
 }
 
-struct CachedPositionAndAccuracy {
+class CachedPositionAndAccuracy
+{
+private:
+  ~CachedPositionAndAccuracy() {}
+public:
+  MOZ_DECLARE_REFCOUNTED_TYPENAME(CachedPositionAndAccuracy)
+  NS_INLINE_DECL_REFCOUNTING(CachedPositionAndAccuracy)
   nsCOMPtr<nsIDOMGeoPosition> position;
   bool isHighAccuracy;
 };
 
 /**
  * Singleton that manages the geolocation provider
  */
 class nsGeolocationService final : public nsIGeolocationUpdate,
@@ -76,17 +82,17 @@ public:
   void HandleMozsettingChanged(nsISupports* aSubject);
   void HandleMozsettingValue(const bool aValue);
 
   // Management of the Geolocation objects
   void AddLocator(mozilla::dom::Geolocation* locator);
   void RemoveLocator(mozilla::dom::Geolocation* locator);
 
   void SetCachedPosition(nsIDOMGeoPosition* aPosition);
-  CachedPositionAndAccuracy GetCachedPosition();
+  already_AddRefed<CachedPositionAndAccuracy> GetCachedPosition();
 
   // Find and startup a geolocation device (gps, nmea, etc.)
   nsresult StartDevice(nsIPrincipal* aPrincipal);
 
   // Stop the started geolocation device (gps, nmea, etc.)
   void     StopDevice();
 
   // create, or reinitalize the callback timer
@@ -109,17 +115,17 @@ private:
   nsCOMPtr<nsIGeolocationProvider> mProvider;
 
   // mGeolocators are not owned here.  Their constructor
   // adds them to this list, and their destructor removes
   // them from this list.
   nsTArray<mozilla::dom::Geolocation*> mGeolocators;
 
   // This is the last geo position that we have seen.
-  CachedPositionAndAccuracy mLastPosition;
+  static mozilla::StaticRefPtr<CachedPositionAndAccuracy> sLastPosition;
 
   // Current state of requests for higher accuracy
   bool mHigherAccuracy;
 };
 
 namespace mozilla {
 namespace dom {
 
